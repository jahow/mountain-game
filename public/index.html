<!DOCTYPE html>
<html>

<head>
	<title>refugedelaigle2016.fr</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/ico" href="favicon.ico"/>
    <link href="style.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans|Open+Sans+Condensed:300|Dosis:400,700|Abel|Roboto+Mono:400,500' rel='stylesheet' type='text/css'>

    <script src="jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js" charset="utf-8"></script>
</head>

<body>

	<header>
		<h1>refugedelaigle<strong>2016</strong></h1>
		<h2>soyez le premier au sommet !</h2>
	</header>

	<div id="gameview">

		<div id="background">

			<svg viewBox="-2000 0 4000 500" preserveAspectRatio="xMidYMid slice">
			</svg>

		</div>

		<div class="fade fade_left"></div>
		<div class="fade fade_right"></div>
		<div class="fade fade_bottom"></div>
		<div class="fade fade_top"></div>

		<div id="portraits">
			<div id="player_portrait_template" class="portrait no_momentum">
				<div class="name">name</div>
				<p>
					&nbspalt: 4300m<br>
					dist: 42315m
				</p>
				<svg class="arrow" viewBox="-100 -100 200 200" width="200" height="200">
					<rect x="-20" y="-5" width="20" height="10" fill="red" /> 
					<polygon points="0,0 0,10 10,0 0,-10 0,0" fill="red" />
				</svg>
				<div class="momentum"> +1</div>
				<div class="water">
					<svg class="outside" width="150" height="200" viewBox="-75 20 150 200">
						<path d="
							M0,180
							L-20,180
							A10,10 0 0,1 -30,170
							L-30,100
							A30,30 0 0,1 -20,90
							A10,10 0 0,0 -10,80
							L10,80
							A10,10 0 0,0 20,90
							A30,30 0 0,1 30,100
							L30 170
							A10,10 0 0,1 20,180
							L0,180" transform="scale(0.35)" />
						<rect x="-10" y="60" width="20" height="10" transform="scale(0.35)" />
					</svg>
					<svg class="inside" width="150" height="200" viewBox="-75 20 150 200">
						<path d="
							M0,180
							L-20,180
							A10,10 0 0,1 -30,170
							L-30,100
							A30,30 0 0,1 -20,90
							A10,10 0 0,0 -10,80
							L10,80
							A10,10 0 0,0 20,90
							A30,30 0 0,1 30,100
							L30 170
							A10,10 0 0,1 20,180
							L0,180" transform="scale(0.35)" />
						<rect x="-10" y="60" width="20" height="10" transform="scale(0.35)" />
					</svg>
				</div>
			</div>
		</div>

		<div id="player_ui">
			<svg width="500" height="300" viewBox="-250 0 500 300">
				<path d="
					M-140,170
					A200,200 0 0,1 -25,110
					L0,50
					L25,110
					A200,200 0 0,1 140,170"
					stroke="white" stroke-width="10" fill="none" transform="scale(0.5)" />
			</svg>
			<object id="bootprint_template" class="bootprint" data="/boot-print.svg" type="image/svg+xml"></object>
		</div>

		<div id="upgrade_ui">
			<div id="currency">
				<object class="booticon1" data="/boot-print.svg" type="image/svg+xml"></object>
				<object class="booticon2" data="/boot-print.svg" type="image/svg+xml"></object>
				<span>0</span>
			</div>
		</div>

	</div>

</body>

<script>


// CONSTANTS

var SEGMENT_SIZE = 100;		// size of segments on screen
var DIST_PER_NODE = 100;	// meters between two nodes
var ADVANCE_PER_CLICK = 2;	// don't change this please
var BASE_WATER_CONSUMPTION = 0.002;


// BACKGROUND DISPLAY

// current focus of the background curve & refresh
var current_background_position_x = 0;	// given in dist coordinates
var previous_background_position_x = 0;
var current_background_position_y = 0;
var previous_background_position_y = 0;

function setBackgroundPosition(x_pos, y_pos) {
	current_background_position_x = x_pos;
	current_background_position_y = y_pos;
	refreshPlayerPortraits();
	refreshBackgroundShapes();
}

function refreshBackgroundShapes() {
	// init
	var range = 1000 / SEGMENT_SIZE;		// lines are displayed on a 2000px width
	var svg = d3.select('#background svg');

	// calc
	var nearest_node = Math.round(current_background_position_x / SEGMENT_SIZE);
	//var current_pos_shift = current_background_position_x - nearest_node * step_size;
	var min_node = nearest_node - range;
	var max_node = nearest_node + range;

	// compute height data (gives an array of altitudes)
	var height_data = computeHeightDataArray(min_node, max_node);
	//console.dir(height_data);

	// apply data
	var lines = svg.selectAll('line').data(height_data, function(d) { return d.node; });

	// enter
	lines.enter().append('line').style('opacity', 0.001);

	// enter+update
	lines
		.attr('x1', function(d, i) { return computeLeftOffset((d.node)*SEGMENT_SIZE, true); })
		.attr('x2', function(d, i) { return computeLeftOffset((d.node+1)*SEGMENT_SIZE, true); })
		.attr('y1', function(d, i) { return computeTopOffset(d.start, true); })
		.attr('y2', function(d, i) { return computeTopOffset(d.end, true); })
		.transition()
		.attr('y1', function(d, i) { return computeTopOffset(d.start); })
		.attr('y2', function(d, i) { return computeTopOffset(d.end); })
		.attr('x1', function(d, i) { return computeLeftOffset((d.node)*SEGMENT_SIZE); })
		.attr('x2', function(d, i) { return computeLeftOffset((d.node+1)*SEGMENT_SIZE); })
		.style('opacity', 1);

	// exit
	lines.exit().transition()
		.attr('x1', function(d, i) { return (d.node)*SEGMENT_SIZE - current_background_position_x; })
		.attr('x2', function(d, i) { return (d.node+1)*SEGMENT_SIZE - current_background_position_x; })
		.style('opacity', 0.001).remove();

	previous_background_position_x = current_background_position_x;
	previous_background_position_y = current_background_position_y;
}

// node_index must be an integer
function computeNodeHeight(node_index) {
	if(node_index <= 0) { return 0; }
	return node_index * 10 + node_index * 5 * Math.cos(node_index * 2);
}

// interpolates between 2 nodes
// pos_x is expressed in dist coordinates
function computeHeight(pos_x) {
	var node_low = Math.floor(pos_x/SEGMENT_SIZE);
	var node_high = Math.ceil(pos_x/SEGMENT_SIZE);
	var ratio = pos_x/SEGMENT_SIZE - node_low;	// between 0 and 1
	return (1-ratio) * computeNodeHeight(node_low) + ratio * computeNodeHeight(node_high);
}

// build an array of height data for a range of nodes
function computeHeightDataArray(min_node, max_node) {
	var result = [];
	for(var i=min_node; i<max_node; i++) {
		result.push({
			node: i,
			start: computeNodeHeight(i),
			end: computeNodeHeight(i+1)
		});
	}
	return result;
}

// gives a factor between 0 and 2, 1 being a flat terrain
function computeSlopeFactor(pos_x) {
	var height_diff = computeNodeHeight(Math.ceil(pos_x/SEGMENT_SIZE)) - computeNodeHeight(Math.floor(pos_x/SEGMENT_SIZE));
	var slope = 1 - 0.01 * height_diff;
	return Math.min(1.7, Math.max(0.3, slope));
}

// computes the 'top' CSS offset based on current game view and given altitude (pos_y)
function computeTopOffset(pos_y, previous) {
	var offset = previous ? previous_background_position_y : current_background_position_y;
	return 250 - pos_y + offset;		// add vertical view shift
}
// same for x pos
function computeLeftOffset(pos_x, previous) {
	var offset = previous ? previous_background_position_x : current_background_position_x;
	return pos_x - offset;
}


// PLAYER MANAGEMENT

// list of players data: x_pos (ie distance), momentum, id, portrait (filename)
// this list is constantly maintained by the server
var current_player_id = 88;
var players_array = [];

// list of dom objects relative to player portraits
var dom_portraits_collection = {};

// temp
players_array.push({
	x_pos: 35,
	momentum: 4,
	id: 88,
	name: 'oliv',
	portrait: 'portrait1.jpg',
	color: 'rgb(177, 97, 105)',
	water: 0.7
});
players_array.push({
	x_pos: 172,
	momentum: 8,
	id: 2,
	name: 'nico',
	portrait: 'portrait2.jpg',
	color: 'rgb(150, 112, 245)',
	water: 0.3
});

//refreshPlayerPortraits();

// takes the players array and refresh DOM objects based on it
function refreshPlayerPortraits() {

	// base portrait template
	var portrait_template = $("#player_portrait_template");
	var portraits_root = $('#portraits');

	var player_data;
	var player_portrait;
	for(var i=0; i<players_array.length; i++) {
		player_data = players_array[i];

		// check if we have a dom object for this one
		if(dom_portraits_collection[player_data.id] == null) {

			// create a new portrait
			player_portrait = portrait_template.clone().appendTo(portraits_root);
			player_portrait.attr('id', player_data.id);
			player_portrait.css({
				'background-image': 'url('+player_data.portrait+')',
				'border-color': player_data.color
			});
			player_portrait.find('.name')
				.css('background-color', player_data.color)
				.html(player_data.name);
			player_portrait.find('svg.arrow *')
				.css('fill', player_data.color);

			// add click callback
			player_portrait.click(function(evt) {
				evt.preventDefault();
				var me = $(this);
				if(!me.hasClass('player_portrait')) { return false; }

				makeStep(me);
				return false;
			});

			dom_portraits_collection[player_data.id] = player_portrait;

		} else {
			player_portrait = dom_portraits_collection[player_data.id];
		}

		// update player portrait pos
		var alt = computeHeight(player_data.x_pos);
		var top = computeTopOffset(alt);
		var left = computeLeftOffset(player_data.x_pos);
		player_portrait.css( {top: top+'px', left: left+'px' } );
		player_portrait.find('p')
				.html('&nbspalt: '+alt.toFixed(0)+'m<br>dist: '+player_data.x_pos.toFixed(1)+'m');
		player_portrait.attr('index', i);

		// momentum arrow
		if(player_data.momentum > 0) {
			player_portrait.removeClass('no_momentum');
			player_portrait.find('.momentum').html('+'+player_data.momentum);

			var scale =  1 + 0.3 * player_data.momentum;
			player_portrait.find('svg.arrow rect').css('transform', 'scale(1,'+scale+')');
			player_portrait.find('svg.arrow polygon').css('transform', 'scale('+scale+')');

			var font_scale = 0.5 + 0.07 * player_data.momentum;
			var width = 14 + 7 * scale;
			// var right = -18 - 6*scale;
			player_portrait.find('.momentum').css({
				'font-size': font_scale+'em',
				'width': width+'px'
				// 'right': right+'px'
			});
		} else {
			player_portrait.addClass('no_momentum');
		}

		// water bottle
		var view_y = 65 - Math.floor(45 * player_data.water);
		var inside = player_portrait.find('.water svg.inside')
			.css('margin-top', view_y - 20);
		inside[0].setAttribute('viewBox', '-75 '+view_y+' 150 200');

		if(current_player_id == player_data.id) {
			player_portrait.addClass('player_portrait');
		} else {
			player_portrait.removeClass('player_portrait');
		}
	}

}

var boot_switched = false;
var steps_count = 0;

// 'me' is the current jquery portrait
function makeStep(me) {
	var player_data = players_array[me.attr('index')];

	// compute how much to advance
	var advance = ADVANCE_PER_CLICK * player_data.momentum;
	var slope = computeSlopeFactor(player_data.x_pos);
	//console.log('slope factor='+slope);
	player_data.x_pos += advance * slope;

	// focus BG 
	setBackgroundPosition(player_data.x_pos, computeHeight(player_data.x_pos));

	// display bootstep
	var boot_template = $('#bootprint_template');
	var ui_root = $('#player_ui');
	var boot = boot_template.clone().attr('id', null).appendTo(ui_root);
	if(boot_switched) { boot.addClass('bootprint_right'); }
	var top = 60 + Math.floor(25 * Math.random());
	var left = -12 + Math.floor(24 * Math.random());
	boot.css( {top: top+'px', 'margin-left': '-'+left+'px' })
		.animate( {top: (top+100)+'px', opacity: 0})
		.queue( function() { $(this).remove(); $(this).dequeue(); });

	boot_switched = !boot_switched;

	// add footstep count
	steps_count++;

	// remove some water
	player_data.water -= BASE_WATER_CONSUMPTION;

	// add upgrade?
	if(Math.random() > 0.95) {
		addNewUpgrade();
	}

	refreshUpgradesStates();
}

// returns the current player data
function getPlayerData() {
	for(var i=0; i<players_array.length; i++) {
		if(players_array[i].id == current_player_id) { return players_array[i]; }
	}
	return null;	// error!
}

// UPGRADES

var upgrade_list = [];	// list of objects with type&cost parameters

// checks if upgrades are available or not
function refreshUpgradesStates() {
	// refresh currency counter
	$('#currency span').html(steps_count);

	var ui_root = $('#upgrade_ui');
	ui_root.find('.upgrade').each( function() {
		var me = $(this);
		var cost = me.attr('cost');
		if(steps_count >= cost) { me.addClass('available'); }
		else { me.removeClass('available'); }
	});
}

// depending on player state, add new upgrade
function addNewUpgrade() {
	if(upgrade_list.length >= 4) { return; }

	var ui_root = $('#upgrade_ui');
	var type = Math.floor(Math.random()*3);
	var cost = 0;
	var name = "";
	var player_data = getPlayerData();
	switch(type) {
		// bond en avant
		case 0: cost = 20 + Math.floor(Math.random() * 40); name = "BOND EN AVANT"; break;
		// élan
		case 1:
			cost = (20 + Math.floor(Math.random() * 20)) * (player_data.momentum+1);
			name = "ELAN +1";
			break;
		// micropur
		case 2: cost = 100 + Math.floor(Math.random() * 200); name = "MICROPUR"; break;
	}
	upgrade_list.push({type: type, cost: cost});

	// add dom object
	var dom_object = $('<div>', {class: 'upgrade type'+type, html: name})
		.attr('cost', cost).attr('type', type).attr('index', upgrade_list.length-1)
		.click(useUpgrade)
		.append($('<span>').html(cost));
	dom_object.appendTo(ui_root);

	dom_object.css({top:'100px', opacity:0}).animate({top:'0px', opacity:1});
}

// callback for upgrade click
function useUpgrade() {
	var me = $(this);
	var cost = me.attr('cost');
	var type = parseInt(me.attr('type'));
	var index = me.attr('index');
	var player_data = getPlayerData();

	if(steps_count < cost) { return false; }

	// use currency & delete me
	steps_count -= cost;
	me.animate({left:'100px', opacity:0}).queue(function() { $(this).remove(); $(this).dequeue(); });

	// do what needs to be done
	console.log('using upgrade type='+type);
	switch(type) {
		// bond en avant
		case 0: player_data.x_pos += 10 + Math.floor(Math.random()*290); break;
		// élan
		case 1: player_data.momentum++; break;
		// micropur
		case 2: player_data.water = 1; break; // TODO
	}

	// remove from array
	upgrade_list.splice(index,1);

	refreshPlayerPortraits();
	refreshUpgradesStates();

	// focus BG 
	setBackgroundPosition(player_data.x_pos, computeHeight(player_data.x_pos));
}

// GAME UPDATE

// this regularly fetches the players data on the server
// also updates current player currency & upgrades available
function updateGame() {



	window.requestAnimationFrame(updateGame);
}





// WINDOW EVENTS

window.onload = function() {
	setBackgroundPosition(0, 0);

	window.requestAnimationFrame(updateGame);
}

window.onresize = function() {
	//refreshBackgroundShapes();
}

</script>

</html>