<!DOCTYPE html>
<html>

<head>
	<title>refugedelaigle2016.fr</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="style.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans|Open+Sans+Condensed:300|Dosis:400,700|Abel|Roboto+Mono:400,500' rel='stylesheet' type='text/css'>

    <script src="jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js" charset="utf-8"></script>
</head>

<body>

	<header>
		<h1>refugedelaigle<strong>2016</strong></h1>
		<h2>soyez le premier au sommet!</h2>
	</header>

	<div id="gameview">

		<div id="portraits">
			<div class="portrait" style="background-image: url(portrait1.jpg)">
				<p>
					&nbspalt: 4300m<br>
					dist: 42315m
				</p>
			</div>

			<div class="portrait" style="background-image: url(portrait2.jpg)">
				<p>
					&nbspalt: 450m<br>
					dist: 815m
				</p>
			</div>
		</div>

		<div id="background">

			<svg viewBox="-2000 0 4000 400" preserveAspectRatio="xMidYMid slice">
			</svg>

		</div>

	</div>

</body>

<script>

// height data
//var height_data = [0,10,50,30,80,85,75,61,43,55,88,92,101,120,108,95];

// current focus of the background curve & refresh
var current_background_position = 0;
var previous_background_position = 0;
setBackgroundPosition(0);

function setBackgroundPosition(pos) {
	current_background_position = pos;
	refreshBackgroundShapes();
}

function refreshBackgroundShapes() {
	// init
	var step_size = 50;
	var range = Math.floor(document.body.clientWidth / step_size / 2);
	var svg = d3.select('#background svg');

	// calc
	var nearest_node = Math.round(current_background_position / step_size);
	//var current_pos_shift = current_background_position - nearest_node * step_size;
	var min_node = nearest_node - range;
	var max_node = nearest_node + range;

	/*
	var shape;
	for(var i=min_node; i<max_node; i++) {
		if(!height_data[i]) { continue; }

		// check if shape exist
		shape = svg.select("line.node"+i);
		if(shape.empty()) {
			shape = svg.append('line')
				.attr('stroke', 'white')
				.attr('stroke-width', 8)
				.attr('class', 'node'+i);
		}
		shape.attr('x1', current_background_position + step_size*i)
			.attr('x2', current_background_position + step_size*(i+1))
			.attr('y1', height_data[i])
			.attr('y2', height_data[i+1]);
	}
	*/

	// compute height data (gives an array of altitudes)
	var height_data = computeHeightDataArray(min_node, max_node);
	//console.dir(height_data);

	// apply data
	var lines = svg.selectAll('line').data(height_data, function(d) { return d.node; });

	// enter
	lines.enter().append('line').style('opacity', 0.001);

	// enter+update
	lines
		.attr('x1', function(d, i) { return (d.node)*step_size - previous_background_position; })
		.attr('x2', function(d, i) { return (d.node+1)*step_size - previous_background_position; })
		.attr('y1', function(d, i) { return 300-d.start; })
		.attr('y2', function(d, i) { return 300-d.end; })
		.transition()
		.attr('x1', function(d, i) { return (d.node)*step_size - current_background_position; })
		.attr('x2', function(d, i) { return (d.node+1)*step_size - current_background_position; })
		.style('opacity', function(d, i) {
			return Math.max(0, Math.min(1, 2 - 2.2*Math.abs(i+0.5-range)/range));
		});

	// exit
	lines.exit().remove();

	previous_background_position = current_background_position;
}

function computeHeightData(pos_x) {
	if(pos_x < 0) { return 0; }
	var alt = pos_x * 10 + pos_x * 5 * Math.cos(pos_x * 2);
	return alt;
}

function computeHeightDataArray(min_node, max_node) {
	var result = [];
	for(var i=min_node; i<max_node; i++) {
		result.push({
			node: i,
			start: computeHeightData(i),
			end: computeHeightData(i+1)
		});
	}
	return result;
}


window.onresize = function() {
	refreshBackgroundShapes();
}

</script>

</html>